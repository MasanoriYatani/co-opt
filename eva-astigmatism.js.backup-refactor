/**
 * Astigmatism Diagram Calculator
 * éç‚¹åå·®å›³è¨ˆç®—ã‚·ã‚¹ãƒ†ãƒ 
 * 
 * å®šç¾©:
 * - åƒé«˜ã¾ãŸã¯ç”»è§’ã‚’ç¸¦è»¸ã«å–ã‚Šã€ä¸»å…‰ç·šè¿‘å‚ã®å¾®å°å…‰æŸã«ã‚ˆã‚‹æ¨ªç·šï¼ˆå­åˆæ–­é¢å…‰æŸã«ã‚ˆã‚‹çµåƒã§
 *   Meridionalåƒé¢ã¨å‘¼ã³ã€Mã¨è¡¨è¨˜ï¼‰åŠã³ç¸¦ç·šï¼ˆçƒæ¬ æ–­é¢å…‰æŸã«ã‚ˆã‚‹çµåƒã§Sagittalåƒé¢ã¨å‘¼ã³
 *   Sã¨è¡¨è¨˜ï¼‰ã®çµåƒç‚¹ã®ã€è¿‘è»¸åƒç‚¹ã‹ã‚‰ã®å·®åˆ†é‡ã‚’æ¨ªè»¸ã«ãƒ—ãƒ­ãƒƒãƒˆã—ãŸã‚‚ã®ã‚’ã¤ãªã„ã æ›²ç·š
 * 
 * è¨ˆç®—æ–¹æ³•ï¼ˆå®Ÿå…‰ç·šè¿½è·¡ã«ã‚ˆã‚‹æ•°å€¤è¨ˆç®—ï¼‰:
 * 1. å„ç”»è§’ã§ä¸»å…‰ç·šã¨æ‰‡å½¢å…‰ç·šãƒ•ã‚¡ãƒ³ï¼ˆã‚¿ãƒ³ã‚¸ã‚§ãƒ³ã‚·ãƒ£ãƒ«/ã‚µã‚¸ã‚¿ãƒ«ï¼‰ã‚’è¿½è·¡
 * 2. å„zä½ç½®ã§æ¨ªåå·®RMSã‚’è©•ä¾¡
 * 3. RMSãŒæœ€å°ã¨ãªã‚‹zä½ç½®ã‚’æœ€è‰¯ç„¦ç‚¹ä½ç½®ã¨ã—ã¦æ¡ç”¨
 * 4. ãƒ‘ãƒ©ã‚­ã‚·ãƒ£ãƒ«åƒé¢ã‹ã‚‰ã®å·®åˆ†ã‚’ãƒ—ãƒ­ãƒƒãƒˆ
 * 
 * æ©Ÿèƒ½:
 * - ãƒ¡ãƒªãƒ‡ã‚£ã‚ªãƒŠãƒ«ï¼ˆMeridional, Mï¼‰åƒé¢ä½ç½®ã®è¨ˆç®— - YZé¢ã®æ‰‡å½¢å…‰ç·šãƒ•ã‚¡ãƒ³
 * - ã‚µã‚¸ã‚¿ãƒ«ï¼ˆSagittal, Sï¼‰åƒé¢ä½ç½®ã®è¨ˆç®— - XZé¢ã®æ‰‡å½¢å…‰ç·šãƒ•ã‚¡ãƒ³
 * - RMSãƒ™ãƒ¼ã‚¹ã®æœ€è‰¯ç„¦ç‚¹æ¢ç´¢
 * - ç”»è§’ã«å¯¾ã™ã‚‹éç‚¹åå·®ã®è©•ä¾¡
 * - ç„¡é™ç³»å¯¾å¿œ
 * 
 * ä½œæˆæ—¥: 2025/01/XX
 * æ›´æ–°æ—¥: 2025/11/14 - RMSãƒ™ãƒ¼ã‚¹ã®å®Ÿå…‰ç·šè¿½è·¡ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã«å¤‰æ›´
 * æ›´æ–°æ—¥: 2025/11/14 - Draw Crossã®å¢ƒç•Œå…‰ç·šæ¤œç´¢ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’æ¡ç”¨
 */

import { calculateChiefRayNewton } from './eva-transverse-aberration.js';
import { getObjectRows, getSourceRows } from './utils/data-utils.js';

/**
 * çµã‚Šé¢ã‚’æ¤œå‡º
 * @param {Array} opticalSystemRows - å…‰å­¦ç³»ãƒ‡ãƒ¼ã‚¿
 * @returns {number} çµã‚Šé¢ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
 */
function findStopSurfaceIndex(opticalSystemRows) {
    // STOã‚¿ã‚¤ãƒ—ã‚’æ¢ã™
    for (let i = 0; i < opticalSystemRows.length; i++) {
        const row = opticalSystemRows[i];
        if (row.surface_type === 'STO' || 
            row['object type'] === 'STO' || 
            String(row.object).toUpperCase() === 'STO') {
            return i;
        }
    }
    
    // æœ€å°é–‹å£é¢ã‚’æ¢ã™
    let minApertureIndex = -1;
    let minAperture = Infinity;
    
    for (let i = 0; i < opticalSystemRows.length; i++) {
        const row = opticalSystemRows[i];
        if (row['object type'] === 'Object' || 
            row['object type'] === 'Image' || 
            row.surface_type === 'Object' || 
            row.surface_type === 'Image') {
            continue;
        }
        
        const aperture = parseFloat(row.aperture || row.Aperture || row.semidia);
        
        if (!isNaN(aperture) && aperture > 0 && aperture < minAperture) {
            minAperture = aperture;
            minApertureIndex = i;
        }
    }
    
    if (minApertureIndex === -1) {
        return 6; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
    }
    
    return minApertureIndex;
}

/**
 * è¿‘è»¸åƒç‚¹ï¼ˆç†æƒ³åƒç‚¹ï¼‰ã®ä½ç½®ã‚’è¨ˆç®—
 * ä¸»å…‰ç·šãŒè©•ä¾¡é¢ã¨äº¤ã‚ã‚‹ç‚¹ã‚’è¿‘è»¸åƒç‚¹ã¨ã™ã‚‹
 * @param {Object} chiefRay - ä¸»å…‰ç·šãƒ‡ãƒ¼ã‚¿ï¼ˆç¬¬0é¢ã‹ã‚‰é–‹å§‹ï¼‰
 * @param {number} targetSurfaceIndex - è©•ä¾¡é¢ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆçµ¶å¯¾ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼‰
 * @returns {number|null} Zåº§æ¨™ï¼ˆè¿‘è»¸åƒç‚¹ä½ç½®ï¼‰
 */
function calculateParaxialImagePosition(chiefRay, targetSurfaceIndex) {
    if (!chiefRay || !chiefRay.segments || chiefRay.segments.length === 0) {
        console.warn('      âš ï¸ calculateParaxialImagePosition: ä¸»å…‰ç·šãƒ‡ãƒ¼ã‚¿ãŒä¸æ­£ã§ã™');
        return null;
    }
    
    console.log(`      ğŸ” ä¸»å…‰ç·šã‚»ã‚°ãƒ¡ãƒ³ãƒˆæ•°: ${chiefRay.segments.length}, è©•ä¾¡é¢ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹: ${targetSurfaceIndex}`);
    
    // è©•ä¾¡é¢ã§ã®ä¸»å…‰ç·šä½ç½®ã‚’å–å¾—ï¼ˆçµ¶å¯¾ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ä½¿ç”¨ï¼‰
    if (targetSurfaceIndex >= chiefRay.segments.length) {
        console.warn(`      âš ï¸ calculateParaxialImagePosition: targetSurfaceIndex=${targetSurfaceIndex}ãŒç¯„å›²å¤–ã§ã™ï¼ˆæœ€å¤§: ${chiefRay.segments.length - 1}ï¼‰`);
        return null;
    }
    
    const targetSegment = chiefRay.segments[targetSurfaceIndex];
    if (!targetSegment) {
        console.warn(`      âš ï¸ calculateParaxialImagePosition: targetSegmentãŒå–å¾—ã§ãã¾ã›ã‚“`);
        return null;
    }
    
    // è¿‘è»¸åƒç‚¹ã¯ä¸»å…‰ç·šã®å…‰è»¸ã¨ã®äº¤ç‚¹
    // findAxisIntersection ã‚’ä½¿ç”¨ã—ã¦ä¸»å…‰ç·šã®ç„¦ç‚¹ä½ç½®ã‚’è¨ˆç®—
    const paraxialZ = findAxisIntersection(chiefRay, targetSurfaceIndex);
    
    if (paraxialZ === null) {
        console.warn('      âš ï¸ calculateParaxialImagePosition: ä¸»å…‰ç·šã®ç„¦ç‚¹è¨ˆç®—ã«å¤±æ•—');
        return null;
    }
    
    console.log(`      ğŸ“ è¿‘è»¸åƒç‚¹ä½ç½®: Z = ${paraxialZ.toFixed(4)}mm`);
    return paraxialZ;
}

/**
 * å…‰ç·šã¨å…‰è»¸ã®äº¤ç‚¹ã‚’è¨ˆç®—ï¼ˆZè»¸ã¨ã®äº¤ç‚¹ï¼‰
 * @param {Object} rayData - å…‰ç·šãƒ‡ãƒ¼ã‚¿
 * @param {number} targetSurfaceIndex - è©•ä¾¡é¢ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
 * @returns {number|null} Zåº§æ¨™ï¼ˆåƒé¢ä½ç½®ï¼‰
 */
function findAxisIntersection(rayData, targetSurfaceIndex) {
    if (!rayData || !rayData.segments || rayData.segments.length === 0) {
        console.warn('      âš ï¸ findAxisIntersection: rayDataãŒä¸æ­£ã§ã™');
        return null;
    }
    
    // è©•ä¾¡é¢ã§ã®å…‰ç·šä½ç½®ã‚’å–å¾—
    const targetSegment = rayData.segments[targetSurfaceIndex];
    if (!targetSegment) {
        console.warn(`      âš ï¸ findAxisIntersection: targetSurfaceIndex=${targetSurfaceIndex}ã®ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“`);
        return null;
    }
    
    // æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—ï¼ˆæ¬¡ã®ç‚¹ã€ã¾ãŸã¯å‰ã®ç‚¹ã¨ã®å·®åˆ†ï¼‰
    let dx, dy, dz;
    const nextIndex = targetSurfaceIndex + 1;
    const prevIndex = targetSurfaceIndex - 1;
    
    if (nextIndex < rayData.segments.length) {
        // æ¬¡ã®ç‚¹ãŒå­˜åœ¨ã™ã‚‹å ´åˆï¼ˆé€šå¸¸ã‚±ãƒ¼ã‚¹ï¼‰
        const nextSegment = rayData.segments[nextIndex];
        dx = nextSegment.x - targetSegment.x;
        dy = nextSegment.y - targetSegment.y;
        dz = nextSegment.z - targetSegment.z;
        console.log(`      ğŸ” æ–¹å‘è¨ˆç®—: è©•ä¾¡é¢ â†’ æ¬¡ã®é¢`);
    } else if (prevIndex >= 0) {
        // è©•ä¾¡é¢ãŒæœ€çµ‚é¢ã®å ´åˆã€å‰ã®ç‚¹ã¨ã®å·®åˆ†ã‚’ä½¿ç”¨
        const prevSegment = rayData.segments[prevIndex];
        dx = targetSegment.x - prevSegment.x;
        dy = targetSegment.y - prevSegment.y;
        dz = targetSegment.z - prevSegment.z;
        console.log(`      ğŸ” æ–¹å‘è¨ˆç®—: å‰ã®é¢ â†’ è©•ä¾¡é¢ï¼ˆæœ€çµ‚é¢ï¼‰`);
    } else {
        console.warn(`      âš ï¸ findAxisIntersection: æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«è¨ˆç®—ä¸å¯ï¼ˆã‚»ã‚°ãƒ¡ãƒ³ãƒˆãŒ1ã¤ã®ã¿ï¼‰`);
        return null;
    }
    
    // æ­£è¦åŒ–
    const length = Math.sqrt(dx*dx + dy*dy + dz*dz);
    if (length < 1e-10) {
        console.warn('      âš ï¸ findAxisIntersection: æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ãŒè¨ˆç®—ã§ãã¾ã›ã‚“');
        return null;
    }
    
    const L = dx / length;
    const M = dy / length;
    const N = dz / length;
    
    const { x, y, z } = targetSegment;
    
    console.log(`      ğŸ” è©•ä¾¡é¢ã§ã®å…‰ç·š: (${x.toFixed(4)}, ${y.toFixed(4)}, ${z.toFixed(4)})`);
    console.log(`      ğŸ” æ–¹å‘: (L=${L.toFixed(6)}, M=${M.toFixed(6)}, N=${N.toFixed(6)})`);
    
    // å…‰ç·šãŒå…‰è»¸ã¨ã»ã¼å¹³è¡Œï¼ˆNâ‰ˆ0ï¼‰ã®å ´åˆã¯è¨ˆç®—ä¸å¯
    if (Math.abs(N) < 1e-10) {
        console.warn('      âš ï¸ å…‰ç·šãŒå…‰è»¸ã¨ã»ã¼å¹³è¡Œã§ã™');
        return null;
    }
    
    // å…‰è»¸ã¨ã®äº¤ç‚¹ã‚’è¨ˆç®—
    // X = 0, Y = 0 ã¨ãªã‚‹ä½ç½®ã‚’æ±‚ã‚ã‚‹
    // X(t) = x + L*t = 0 â†’ t_x = -x/L
    // Y(t) = y + M*t = 0 â†’ t_y = -y/M
    
    let t;
    if (Math.abs(L) > Math.abs(M)) {
        // LãŒå¤§ãã„å ´åˆã€X=0ã®æ¡ä»¶ã‚’ä½¿ç”¨
        t = -x / L;
        console.log(`      ğŸ” X=0æ¡ä»¶ã§t=${t.toFixed(4)}`);
    } else if (Math.abs(M) > 1e-10) {
        // MãŒå¤§ãã„å ´åˆã€Y=0ã®æ¡ä»¶ã‚’ä½¿ç”¨
        t = -y / M;
        console.log(`      ğŸ” Y=0æ¡ä»¶ã§t=${t.toFixed(4)}`);
    } else {
        // L, Mä¸¡æ–¹ãŒå°ã•ã„å ´åˆã€ã™ã§ã«å…‰è»¸ä¸Šã«ã‚ã‚‹
        console.log(`      â„¹ï¸ å…‰è»¸ä¸Šã«ã‚ã‚Šã¾ã™: Z=${z.toFixed(4)}`);
        return z;
    }
    
    // å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯: tãŒç•°å¸¸ã«å¤§ãã„å ´åˆã¯ç„¦ç‚¹ãŒãªã„ï¼ˆç™ºæ•£å…‰ç·šï¼‰
    const MAX_REASONABLE_DISTANCE = 1000; // 1000mmä»¥ä¸Šã¯ç•°å¸¸å€¤ã¨ã¿ãªã™
    if (Math.abs(t) > MAX_REASONABLE_DISTANCE) {
        console.warn(`      âš ï¸ ç„¦ç‚¹è·é›¢ãŒç•°å¸¸ (t=${t.toFixed(1)}mm): å…‰ç·šãŒç™ºæ•£ã—ã¦ã„ã¾ã™`);
        return null;
    }
    
    // Zåº§æ¨™ã‚’è¨ˆç®—
    const z_intersection = z + N * t;
    
    console.log(`      âœ… å…‰è»¸äº¤ç‚¹: Z=${z_intersection.toFixed(4)}mm`);
    
    return z_intersection;
}

/**
 * å…‰ç·šã‚’æŒ‡å®šã®Zå¹³é¢ã«æŠ•å½±ã—ã¦ã€ãã®å¹³é¢ã§ã®äº¤ç‚¹ã‚’è¨ˆç®—
 * @param {Object} segment - å…‰ç·šã‚»ã‚°ãƒ¡ãƒ³ãƒˆï¼ˆå§‹ç‚¹ï¼‰
 * @param {Object} nextSegment - æ¬¡ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆï¼ˆæ–¹å‘ã‚’æ±ºå®šï¼‰
 * @param {number} targetZ - ç›®æ¨™ã®Zåº§æ¨™
 * @returns {Object|null} {x, y, z} äº¤ç‚¹åº§æ¨™
 */
function projectRayToZ(segment, nextSegment, targetZ) {
    const dx = nextSegment.x - segment.x;
    const dy = nextSegment.y - segment.y;
    const dz = nextSegment.z - segment.z;
    
    // Zæ–¹å‘ã®å¤‰åŒ–ãŒã»ã¼ã‚¼ãƒ­ã®å ´åˆã¯æŠ•å½±ä¸å¯
    if (Math.abs(dz) < 1e-10) {
        return null;
    }
    
    // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿tã‚’è¨ˆç®—: segment.z + t * dz = targetZ
    const t = (targetZ - segment.z) / dz;
    
    // äº¤ç‚¹ã‚’è¨ˆç®—
    return {
        x: segment.x + t * dx,
        y: segment.y + t * dy,
        z: targetZ
    };
}

/**
 * æŒ‡å®šã®Zå¹³é¢ã§ã®æ¨ªåå·®RMSã‚’è¨ˆç®—
 * @param {Array} rayFan - å…‰ç·šãƒ•ã‚¡ãƒ³ã®é…åˆ— [{segments: [...], ...}, ...]
 * @param {Object} chiefRay - ä¸»å…‰ç·šãƒ‡ãƒ¼ã‚¿
 * @param {number} targetSurfaceIndex - è©•ä¾¡é¢ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
 * @param {number} targetZ - è©•ä¾¡ã™ã‚‹Zå¹³é¢ã®åº§æ¨™
 * @param {string} direction - 'meridional' ã¾ãŸã¯ 'sagittal'
 * @returns {number|null} RMSå€¤
 */
function calculateRMSAtZ(rayFan, chiefRay, targetSurfaceIndex, targetZ, direction) {
    // ä¸»å…‰ç·šã®è©•ä¾¡é¢ã§ã®ä½ç½®ã¨æ–¹å‘
    const chiefSegment = chiefRay.segments[targetSurfaceIndex];
    const chiefNextIndex = targetSurfaceIndex + 1;
    const chiefPrevIndex = targetSurfaceIndex - 1;
    
    if (!chiefSegment) {
        return null;
    }
    
    // ä¸»å…‰ç·šã®æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—ï¼ˆæ¬¡ã®ç‚¹ã€ã¾ãŸã¯å‰ã®ç‚¹ï¼‰
    let chiefNextSegment;
    if (chiefNextIndex < chiefRay.segments.length) {
        chiefNextSegment = chiefRay.segments[chiefNextIndex];
    } else if (chiefPrevIndex >= 0) {
        // æœ€çµ‚é¢ã®å ´åˆã€å‰ã®ç‚¹ã‚’ä½¿ç”¨ã—ã¦æ–¹å‘ã‚’é€†ç®—
        const chiefPrevSegment = chiefRay.segments[chiefPrevIndex];
        // å‰ã®ç‚¹ã‹ã‚‰ç¾åœ¨ç‚¹ã¸ã®æ–¹å‘ã‚’ä½¿ç”¨
        chiefNextSegment = {
            x: chiefSegment.x + (chiefSegment.x - chiefPrevSegment.x),
            y: chiefSegment.y + (chiefSegment.y - chiefPrevSegment.y),
            z: chiefSegment.z + (chiefSegment.z - chiefPrevSegment.z)
        };
    } else {
        return null;
    }
    
    // ä¸»å…‰ç·šã®targetZã§ã®ä½ç½®ã‚’è¨ˆç®—
    const chiefAtZ = projectRayToZ(chiefSegment, chiefNextSegment, targetZ);
    if (!chiefAtZ) {
        return null;
    }
    
    // å„å…‰ç·šã®targetZã§ã®ä½ç½®ã‚’è¨ˆç®—ã—ã€ä¸»å…‰ç·šã¨ã®åå·®ã‚’æ±‚ã‚ã‚‹
    const deviations = [];
    
    for (const ray of rayFan) {
        if (!ray || !ray.segments || ray.segments.length <= targetSurfaceIndex) {
            continue; // ã‚±ãƒ©ãƒ¬ãªã©ã§åˆ°é”ã—ã¦ã„ãªã„å…‰ç·šã¯ã‚¹ã‚­ãƒƒãƒ—
        }
        
        const segment = ray.segments[targetSurfaceIndex];
        
        // å…‰ç·šã®æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—
        let nextSegment;
        if (targetSurfaceIndex + 1 < ray.segments.length) {
            nextSegment = ray.segments[targetSurfaceIndex + 1];
        } else if (targetSurfaceIndex - 1 >= 0) {
            // æœ€çµ‚é¢ã®å ´åˆ
            const prevSegment = ray.segments[targetSurfaceIndex - 1];
            nextSegment = {
                x: segment.x + (segment.x - prevSegment.x),
                y: segment.y + (segment.y - prevSegment.y),
                z: segment.z + (segment.z - prevSegment.z)
            };
        } else {
            continue;
        }
        
        const rayAtZ = projectRayToZ(segment, nextSegment, targetZ);
        if (!rayAtZ) {
            continue;
        }
        
        // ãƒ¡ãƒªãƒ‡ã‚£ã‚ªãƒŠãƒ«ï¼ˆYZé¢ï¼‰ã§ã¯Yæ–¹å‘ã®åå·®ã€ã‚µã‚¸ã‚¿ãƒ«ï¼ˆXZé¢ï¼‰ã§ã¯Xæ–¹å‘ã®åå·®
        const deviation = direction === 'meridional' 
            ? (rayAtZ.y - chiefAtZ.y)
            : (rayAtZ.x - chiefAtZ.x);
        
        deviations.push(deviation);
    }
    
    if (deviations.length === 0) {
        return null;
    }
    
    // RMSè¨ˆç®—
    const sumSq = deviations.reduce((sum, dev) => sum + dev * dev, 0);
    const rms = Math.sqrt(sumSq / deviations.length);
    
    return rms;
}

/**
 * RMSãŒæœ€å°ã¨ãªã‚‹Zä½ç½®ã‚’æ¢ç´¢
 * @param {Array} rayFan - å…‰ç·šãƒ•ã‚¡ãƒ³ã®é…åˆ—
 * @param {Object} chiefRay - ä¸»å…‰ç·šãƒ‡ãƒ¼ã‚¿
 * @param {number} targetSurfaceIndex - è©•ä¾¡é¢ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
 * @param {number} paraxialZ - ãƒ‘ãƒ©ã‚­ã‚·ãƒ£ãƒ«åƒé¢ã®Zåº§æ¨™
 * @param {string} direction - 'meridional' ã¾ãŸã¯ 'sagittal'
 * @returns {number|null} æœ€è‰¯ç„¦ç‚¹ã®Zåº§æ¨™
 */
function findBestFocusZ(rayFan, chiefRay, targetSurfaceIndex, paraxialZ, direction) {
    console.log(`      ğŸ” æœ€è‰¯ç„¦ç‚¹æ¢ç´¢: å…‰ç·šãƒ•ã‚¡ãƒ³=${rayFan.length}æœ¬, è¿‘è»¸åƒç‚¹=${paraxialZ.toFixed(4)}mm`);
    
    // æ¢ç´¢ç¯„å›²ï¼šãƒ‘ãƒ©ã‚­ã‚·ãƒ£ãƒ«åƒé¢ Â± 10mm
    const searchRange = 10; // mm
    const zMin = paraxialZ - searchRange;
    const zMax = paraxialZ + searchRange;
    const numSamples = 41; // 0.5mmåˆ»ã¿
    
    console.log(`      ğŸ” æ¢ç´¢ç¯„å›²: ${zMin.toFixed(2)}mm ~ ${zMax.toFixed(2)}mm (${numSamples}ç‚¹)`);
    
    let bestZ = paraxialZ;
    let minRMS = Infinity;
    let validSamples = 0;
    
    for (let i = 0; i < numSamples; i++) {
        const z = zMin + (zMax - zMin) * i / (numSamples - 1);
        const rms = calculateRMSAtZ(rayFan, chiefRay, targetSurfaceIndex, z, direction);
        
        if (rms !== null) {
            validSamples++;
            if (rms < minRMS) {
                minRMS = rms;
                bestZ = z;
            }
        }
    }
    
    console.log(`      ğŸ“Š æœ‰åŠ¹ã‚µãƒ³ãƒ—ãƒ«: ${validSamples}/${numSamples}, æœ€å°RMS=${minRMS.toFixed(6)}mm`);
    
    if (minRMS === Infinity) {
        console.warn(`      âš ï¸ å…¨ã¦ã®ã‚µãƒ³ãƒ—ãƒ«ã§RMSè¨ˆç®—å¤±æ•—`);
        return null;
    }
    
    console.log(`      ğŸ“Š ${direction} æœ€è‰¯ç„¦ç‚¹: Z=${bestZ.toFixed(4)}mm, RMS=${minRMS.toFixed(6)}mm`);
    
    return bestZ;
}

/**
 * ãƒ¡ãƒªãƒ‡ã‚£ã‚ªãƒŠãƒ«ï¼ˆMeridional, Mï¼‰æ‰‡å½¢å…‰ç·šãƒ•ã‚¡ãƒ³ã‚’è¿½è·¡ã—ã¦RMSãƒ™ãƒ¼ã‚¹ã®æœ€è‰¯ç„¦ç‚¹ã‚’è¨ˆç®—
 * YZé¢ï¼ˆå­åˆæ–­é¢ï¼‰ã®å…‰ç·šãƒ•ã‚¡ãƒ³
 * @param {Array} opticalSystemRows - å…‰å­¦ç³»ãƒ‡ãƒ¼ã‚¿
 * @param {Object} chiefRay - ä¸»å…‰ç·šãƒ‡ãƒ¼ã‚¿
 * @param {Object} chiefRayResult - calculateChiefRayNewtonã®å®Œå…¨ãªè¿”ã‚Šå€¤ï¼ˆstartP, dirã‚’å«ã‚€ï¼‰
 * @param {number} wavelength - æ³¢é•· (Î¼m)
 * @param {number} stopSurfaceIndex - çµã‚Šé¢ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
 * @param {number} targetSurfaceIndex - è©•ä¾¡é¢ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
 * @param {number} paraxialZ - ãƒ‘ãƒ©ã‚­ã‚·ãƒ£ãƒ«åƒé¢ã®Zåº§æ¨™
 * @returns {number|null} æœ€è‰¯ç„¦ç‚¹ã®Zåº§æ¨™
 */
function traceMeridionalMarginalRay(opticalSystemRows, chiefRay, chiefRayResult, wavelength, stopSurfaceIndex, targetSurfaceIndex, paraxialZ) {
    try {
        const stopSurface = opticalSystemRows[stopSurfaceIndex];
        const stopRadius = Math.abs(parseFloat(stopSurface.semidia || stopSurface.aperture || stopSurface.Aperture || 10));
        
        console.log(`      ãƒ¡ãƒªãƒ‡ã‚£ã‚ªãƒŠãƒ«å…‰ç·šãƒ•ã‚¡ãƒ³è¿½è·¡: Draw Crossåå­—å…‰ç·šã‚’ä½¿ç”¨`);
        
        if (!chiefRay || !chiefRay.segments || chiefRay.segments.length <= stopSurfaceIndex) {
            console.warn('      âš ï¸ ãƒ¡ãƒªãƒ‡ã‚£ã‚ªãƒŠãƒ«: ä¸»å…‰ç·šãƒ‡ãƒ¼ã‚¿ãŒä¸æ­£ã§ã™');
            return null;
        }
        
        // Draw Crossã®åå­—å…‰ç·šã‹ã‚‰ç›´æ¥ãƒ¡ãƒªãƒ‡ã‚£ã‚ªãƒŠãƒ«å…‰ç·šã‚’å–å¾—
        if (!chiefRayResult.rayGroups || chiefRayResult.rayGroups.length === 0) {
            console.warn('      âš ï¸ ãƒ¡ãƒªãƒ‡ã‚£ã‚ªãƒŠãƒ«: rayGroupsãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
            return null;
        }
        
        const rayGroup = chiefRayResult.rayGroups[0];
        const upperMarginalRay = rayGroup.rays.find(r => r.rayType === 'upper_marginal');
        const lowerMarginalRay = rayGroup.rays.find(r => r.rayType === 'lower_marginal');
        
        if (!upperMarginalRay || !lowerMarginalRay) {
            console.warn('      âš ï¸ ãƒ¡ãƒªãƒ‡ã‚£ã‚ªãƒŠãƒ«: upper/lower marginalå…‰ç·šãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
            console.warn('      åˆ©ç”¨å¯èƒ½ãªå…‰ç·šã‚¿ã‚¤ãƒ—:', rayGroup.rays.map(r => r.rayType));
            return null;
        }
        
        // ãƒ¡ãƒªãƒ‡ã‚£ã‚ªãƒŠãƒ«å…‰ç·šãƒ•ã‚¡ãƒ³ã‚’æ§‹ç¯‰ï¼ˆ3æœ¬: lower, chief, upperï¼‰
        const rayFan = [];
        
        // Lower marginalå…‰ç·š
        if (lowerMarginalRay.path && lowerMarginalRay.path.length > targetSurfaceIndex) {
            rayFan.push({
                segments: lowerMarginalRay.path,
                type: 'lower_marginal'
            });
        }
        
        // Chiefå…‰ç·š
        rayFan.push({
            segments: chiefRay.segments,
            type: 'chief'
        });
        
        // Upper marginalå…‰ç·š
        if (upperMarginalRay.path && upperMarginalRay.path.length > targetSurfaceIndex) {
            rayFan.push({
                segments: upperMarginalRay.path,
                type: 'upper_marginal'
            });
        }
        
        console.log(`      ï¿½ ãƒ¡ãƒªãƒ‡ã‚£ã‚ªãƒŠãƒ«å…‰ç·šãƒ•ã‚¡ãƒ³: ${rayFan.length}/3 æœ¬è¿½è·¡æˆåŠŸ`);
        
        if (rayFan.length < 2) {
            console.warn('      âš ï¸ ãƒ¡ãƒªãƒ‡ã‚£ã‚ªãƒŠãƒ«: æœ‰åŠ¹ãªå…‰ç·šãŒä¸è¶³ã—ã¦ã„ã¾ã™');
            return null;
        }
        for (let i = 0; i < stopSurfaceIndex; i++) {
            const thickness = parseFloat(opticalSystemRows[i].thickness);
            if (!isNaN(thickness) && isFinite(thickness)) {
                stopZ += thickness;
            }
        }
        
        // Draw Crossã®å¢ƒç•Œå…‰ç·šæ¤œç´¢ã‚’ä½¿ç”¨ï¼ˆstopInfoæ§‹é€ ã‚’Draw Crossã¨åˆã‚ã›ã‚‹ï¼‰
        const stopInfo = {
            surface: stopSurface,
            index: stopSurfaceIndex,
            center: { x: 0, y: 0, z: stopZ },      // çµã‚Šé¢ã®ä¸­å¿ƒåº§æ¨™ï¼ˆå…‰è»¸ä¸Šï¼‰
            position: { x: 0, y: 0, z: stopZ },    // çµã‚Šé¢ã®ä½ç½®åº§æ¨™
            radius: stopRadius,
            origin: { x: 0, y: 0, z: stopZ }       // çµã‚Šé¢ã®åŸç‚¹åº§æ¨™
        };
        
        const boundaryRays = findApertureBoundaryRays(
            chiefOrigin,       // Objecté¢ã§ã®å‡ºç™ºç‚¹
            chiefDirection,    // æ­£è¦åŒ–æ¸ˆã¿ã®æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«
            opticalSystemRows, 
            stopInfo,
            { debugMode: true, wavelength: wavelength }
        );
        
        console.log(`      ğŸ” å¢ƒç•Œå…‰ç·šæ¤œç´¢çµæœ: ${boundaryRays.length}æœ¬`);
        
        // ãƒ¡ãƒªãƒ‡ã‚£ã‚ªãƒŠãƒ«æ–¹å‘ï¼ˆupper/lowerï¼‰ã®å¢ƒç•Œå…‰ç·šã‚’å–å¾—
        const upperRay = boundaryRays.find(r => r.direction === 'upper');
        const lowerRay = boundaryRays.find(r => r.direction === 'lower');
        
        if (!upperRay || !lowerRay) {
            console.warn('      âš ï¸ ãƒ¡ãƒªãƒ‡ã‚£ã‚ªãƒŠãƒ«: upper/lowerå¢ƒç•Œå…‰ç·šãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
            return null;
        }
        
        // å®‰å…¨ãƒãƒ¼ã‚¸ãƒ³ã‚’é©ç”¨ï¼ˆ70%ã®é–‹å£ã‚’ä½¿ç”¨ã—ã¦å¾Œæ®µã§ã®ã‚±ãƒ©ãƒ¬ã‚’å›é¿ï¼‰
        const safetyMargin = 0.70;
        const upperDistance = upperRay.distance * safetyMargin;
        const lowerDistance = lowerRay.distance * safetyMargin;
        
        console.log(`      âœ… Upperå¢ƒç•Œ: distance=${upperRay.distance.toFixed(3)}mm â†’ å®‰å…¨è·é›¢=${upperDistance.toFixed(3)}mm (${(safetyMargin*100).toFixed(0)}%)`);
        console.log(`      âœ… Lowerå¢ƒç•Œ: distance=${lowerRay.distance.toFixed(3)}mm â†’ å®‰å…¨è·é›¢=${lowerDistance.toFixed(3)}mm (${(safetyMargin*100).toFixed(0)}%)`);
        console.log(`      ğŸ” ä¸»å…‰ç·šå‡ºç™ºç‚¹: (${chiefOrigin.x.toFixed(3)}, ${chiefOrigin.y.toFixed(3)}, ${chiefOrigin.z.toFixed(3)})`);
        
        // ä¸»å…‰ç·šã«å‚ç›´ãªåŸºåº•ãƒ™ã‚¯ãƒˆãƒ«ã‚’ç”Ÿæˆï¼ˆmakeBasisã¨åŒã˜ãƒ­ã‚¸ãƒƒã‚¯ï¼‰
        const len = Math.sqrt(chiefDirection.x * chiefDirection.x + chiefDirection.y * chiefDirection.y + chiefDirection.z * chiefDirection.z);
        const d = { x: chiefDirection.x / len, y: chiefDirection.y / len, z: chiefDirection.z / len };
        
        // ç¬¬ä¸€åŸºåº•ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆxè»¸æ–¹å‘ï¼‰
        const ref = Math.abs(d.z) < 0.95 ? { x: 0, y: 0, z: 1 } : { x: 0, y: 1, z: 0 };
        let ex = {
            x: d.y * ref.z - d.z * ref.y,
            y: d.z * ref.x - d.x * ref.z,
            z: d.x * ref.y - d.y * ref.x
        };
        const exLen = Math.sqrt(ex.x * ex.x + ex.y * ex.y + ex.z * ex.z);
        ex = { x: ex.x / exLen, y: ex.y / exLen, z: ex.z / exLen };
        
        // ç¬¬äºŒåŸºåº•ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆyè»¸æ–¹å‘ï¼‰- ãƒ¡ãƒªãƒ‡ã‚£ã‚ªãƒŠãƒ«æ–¹å‘
        let ey = {
            x: d.y * ex.z - d.z * ex.y,
            y: d.z * ex.x - d.x * ex.z,
            z: d.x * ex.y - d.y * ex.x
        };
        const eyLen = Math.sqrt(ey.x * ey.x + ey.y * ey.y + ey.z * ey.z);
        ey = { x: ey.x / eyLen, y: ey.y / eyLen, z: ey.z / eyLen };
        
        console.log(`      ğŸ” åŸºåº•ãƒ™ã‚¯ãƒˆãƒ« ey (meridional): (${ey.x.toFixed(6)}, ${ey.y.toFixed(6)}, ${ey.z.toFixed(6)})`);
        
        // å¢ƒç•Œå…‰ç·šé–“ã§å…‰ç·šãƒ•ã‚¡ãƒ³ã‚’ç”Ÿæˆï¼ˆ7æœ¬: å¢ƒç•Œã‚’é¿ã‘ã¦ã‚ˆã‚Šå¯†ãªã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ï¼‰
        // å¢ƒç•Œä»˜è¿‘ï¼ˆÂ±1.0ï¼‰ã‚’é¿ã‘ã€Â±0.8ã¾ã§ã«åˆ¶é™ã—ã¦å®‰å…¨æ€§ã‚’ç¢ºä¿
        const fanPositions = [-0.8, -0.5, -0.2, 0, 0.2, 0.5, 0.8];
        const rayFan = [];
        
        // ç¬¬1é¢ã®åº§æ¨™ã‚’å–å¾—
        const firstSurfacePoint = chiefRay.segments[1];
        
        for (const ratio of fanPositions) {
            // å¢ƒç•Œè·é›¢ã‚’ç·šå½¢è£œé–“ã—ã¦ã‚¹ã‚±ãƒ¼ãƒ«ï¼ˆå®‰å…¨è·é›¢ã‚’ä½¿ç”¨ï¼‰
            // ratio = -1 â†’ ä¸‹å¢ƒç•Œã®100%, ratio = 0 â†’ 0%, ratio = +1 â†’ ä¸Šå¢ƒç•Œã®100%
            const t = (ratio + 1.0) / 2.0; // -1â†’0, 0â†’0.5, +1â†’1
            const boundaryDistance = lowerDistance * (1-t) + upperDistance * t;
            
            // ratioã®çµ¶å¯¾å€¤ã§ã‚¹ã‚±ãƒ¼ãƒ«ï¼ˆ0ã€œ100%ã®è·é›¢ï¼‰
            const distance = Math.abs(ratio) * boundaryDistance;
            
            // ä¸»å…‰ç·šå‡ºç™ºç‚¹ã‹ã‚‰å‚ç›´æ–¹å‘ã«ã‚ªãƒ•ã‚»ãƒƒãƒˆã—ã¦å…‰ç·šå‡ºç™ºç‚¹ã‚’è¨ˆç®—
            // ãƒ¡ãƒªãƒ‡ã‚£ã‚ªãƒŠãƒ«: eyæ–¹å‘ï¼ˆy'è»¸ï¼‰ã«ã‚ªãƒ•ã‚»ãƒƒãƒˆ
            // ratio < 0 â†’ lower (è² ã®æ–¹å‘), ratio > 0 â†’ upper (æ­£ã®æ–¹å‘)
            const directionSign = (ratio < 0) ? -1 : (ratio > 0) ? 1 : 0;
            const effectiveDistance = distance * directionSign;
            
            const rayOrigin = {
                x: chiefOrigin.x + effectiveDistance * ey.x,
                y: chiefOrigin.y + effectiveDistance * ey.y,
                z: chiefOrigin.z + effectiveDistance * ey.z
            };
            
            console.log(`      ğŸ”¹ å…‰ç·šãƒ•ã‚¡ãƒ³ ${ratio.toFixed(1)}: distance=${distance.toFixed(3)}mm (å¢ƒç•Œ=${boundaryDistance.toFixed(3)}mm, æ–¹å‘=${directionSign}), Objecté¢å‡ºç™ºç‚¹=(${rayOrigin.x.toFixed(3)}, ${rayOrigin.y.toFixed(3)}, ${rayOrigin.z.toFixed(3)})`);
            
            // å…‰ç·šæ–¹å‘ã¯ä¸»å…‰ç·šã¨åŒã˜æ–¹å‘ã‚’ä½¿ç”¨ï¼ˆç„¡é™é ç³»ï¼‰
            const rayDirection = chiefDirection;
            
            // ç¬¬1é¢ã§ã®é–‹å§‹ç‚¹ï¼ˆå°‘ã—æ‰‹å‰ï¼‰
            const distToFirstSurface = firstSurfacePoint.z - rayOrigin.z;
            const tToFirstSurface = distToFirstSurface / rayDirection.z;
            const epsilon = -0.01;
            
            const startPoint = {
                x: rayOrigin.x + rayDirection.x * (tToFirstSurface + epsilon),
                y: rayOrigin.y + rayDirection.y * (tToFirstSurface + epsilon),
                z: firstSurfacePoint.z + epsilon
            };
            
            // å…‰ç·šè¿½è·¡ï¼ˆç¬¬1é¢ã‹ã‚‰ï¼‰
            const surfacesFromFirst = opticalSystemRows.slice(1);
            const ray0 = { pos: startPoint, dir: rayDirection };
            
            // ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ç”¨é…åˆ—
            const debugLog = [];
            const segments = traceRay(surfacesFromFirst, ray0, 1.0, debugLog);
            
            if (!segments || !Array.isArray(segments)) {
                console.warn(`      âš ï¸ ãƒ¡ãƒªãƒ‡ã‚£ã‚ªãƒŠãƒ«å…‰ç·šè¿½è·¡å¤±æ•—: segments=${segments}`);
                if (debugLog.length > 0) {
                    console.log(`      ğŸ“ ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚° (æœ€å¾Œã®10è¡Œ):`, debugLog.slice(-10));
                }
                continue;
            }
            
            console.log(`      âœ… ãƒ¡ãƒªãƒ‡ã‚£ã‚ªãƒŠãƒ«å…‰ç·šè¿½è·¡æˆåŠŸ: ${segments.length}ã‚»ã‚°ãƒ¡ãƒ³ãƒˆ`);
            
            // traceRayã¯ç¬¬1é¢ã‹ã‚‰å§‹ã¾ã‚‹ã®ã§ã€ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’èª¿æ•´
            // targetSurfaceIndexã¯çµ¶å¯¾ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆç¬¬0é¢èµ·ç‚¹ï¼‰
            // segmentsã¯ç¬¬1é¢èµ·ç‚¹ãªã®ã§ã€targetSurfaceIndex - 1 ã‚’ä½¿ç”¨
            const adjustedIndex = targetSurfaceIndex - 1;
            
            console.log(`      ğŸ” å¿…è¦ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæ•°: ${adjustedIndex + 2} (èª¿æ•´æ¸ˆã¿ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹=${adjustedIndex}+2)`);
            
            if (segments.length > adjustedIndex + 1) {
                // ç¬¬0é¢ã®æƒ…å ±ã‚’è¿½åŠ ã—ã¦ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’åˆã‚ã›ã‚‹
                const adjustedSegments = [rayOrigin, ...segments];
                rayFan.push({ segments: adjustedSegments });
                console.log(`      âœ… ãƒ¡ãƒªãƒ‡ã‚£ã‚ªãƒŠãƒ«å…‰ç·šãƒ•ã‚¡ãƒ³è¿½åŠ æˆåŠŸ: èª¿æ•´å¾Œã‚»ã‚°ãƒ¡ãƒ³ãƒˆæ•°=${adjustedSegments.length}`);
            } else {
                console.warn(`      âš ï¸ ãƒ¡ãƒªãƒ‡ã‚£ã‚ªãƒŠãƒ«ã‚»ã‚°ãƒ¡ãƒ³ãƒˆä¸è¶³: ${segments.length} <= ${adjustedIndex + 1}ï¼ˆã‚±ãƒ©ãƒ¬ã¾ãŸã¯åˆ°é”ä¸å¯ï¼‰`);
            }
        }
        
        console.log(`      ğŸ“Š ãƒ¡ãƒªãƒ‡ã‚£ã‚ªãƒŠãƒ«å…‰ç·šãƒ•ã‚¡ãƒ³: ${rayFan.length}/${fanPositions.length} æœ¬è¿½è·¡æˆåŠŸ`);
        
        if (rayFan.length === 0) {
            console.warn('      âš ï¸ ãƒ¡ãƒªãƒ‡ã‚£ã‚ªãƒŠãƒ«: å…‰ç·šãƒ•ã‚¡ãƒ³ãŒ1æœ¬ã‚‚è¿½è·¡ã§ãã¾ã›ã‚“ã§ã—ãŸ');
            return null;
        }
        
        // RMSãƒ™ãƒ¼ã‚¹ã®æœ€è‰¯ç„¦ç‚¹æ¢ç´¢
        const bestZ = findBestFocusZ(rayFan, chiefRay, targetSurfaceIndex, paraxialZ, 'meridional');
        
        if (bestZ === null) {
            console.warn('      âš ï¸ ãƒ¡ãƒªãƒ‡ã‚£ã‚ªãƒŠãƒ«: æœ€è‰¯ç„¦ç‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ');
            return null;
        }
        
        return bestZ;
        
    } catch (error) {
        console.error('      âŒ ãƒ¡ãƒªãƒ‡ã‚£ã‚ªãƒŠãƒ«å…‰ç·šè¿½è·¡ã‚¨ãƒ©ãƒ¼:', error);
        return null;
    }
}

/**
 * ã‚µã‚¸ã‚¿ãƒ«ï¼ˆSagittal, Sï¼‰æ‰‡å½¢å…‰ç·šãƒ•ã‚¡ãƒ³ã‚’è¿½è·¡ã—ã¦RMSãƒ™ãƒ¼ã‚¹ã®æœ€è‰¯ç„¦ç‚¹ã‚’è¨ˆç®—
 * XZé¢ï¼ˆçƒæ¬ æ–­é¢ï¼‰ã®å…‰ç·šãƒ•ã‚¡ãƒ³
 * @param {Array} opticalSystemRows - å…‰å­¦ç³»ãƒ‡ãƒ¼ã‚¿
 * @param {Object} chiefRay - ä¸»å…‰ç·šãƒ‡ãƒ¼ã‚¿
 * @param {Object} chiefRayResult - calculateChiefRayNewtonã®å®Œå…¨ãªè¿”ã‚Šå€¤ï¼ˆstartP, dirã‚’å«ã‚€ï¼‰
 * @param {number} wavelength - æ³¢é•· (Î¼m)
 * @param {number} stopSurfaceIndex - çµã‚Šé¢ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
 * @param {number} targetSurfaceIndex - è©•ä¾¡é¢ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
 * @param {number} paraxialZ - ãƒ‘ãƒ©ã‚­ã‚·ãƒ£ãƒ«åƒé¢ã®Zåº§æ¨™
 * @returns {number|null} æœ€è‰¯ç„¦ç‚¹ã®Zåº§æ¨™
 */
function traceSagittalMarginalRay(opticalSystemRows, chiefRay, chiefRayResult, wavelength, stopSurfaceIndex, targetSurfaceIndex, paraxialZ) {
    try {
        const stopSurface = opticalSystemRows[stopSurfaceIndex];
        const stopRadius = Math.abs(parseFloat(stopSurface.semidia || stopSurface.aperture || stopSurface.Aperture || 10));
        
        console.log(`      ã‚µã‚¸ã‚¿ãƒ«å…‰ç·šãƒ•ã‚¡ãƒ³è¿½è·¡: çµã‚ŠåŠå¾„=${stopRadius.toFixed(3)}mm`);
        
        if (!chiefRay || !chiefRay.segments || chiefRay.segments.length <= stopSurfaceIndex) {
            console.warn('      âš ï¸ ã‚µã‚¸ã‚¿ãƒ«: ä¸»å…‰ç·šãƒ‡ãƒ¼ã‚¿ãŒä¸æ­£ã§ã™');
            return null;
        }
        
        // Objecté¢ã§ã®ä¸»å…‰ç·šå‡ºç™ºç‚¹ã¨æ–¹å‘ï¼ˆcalculateChiefRayNewtonã‹ã‚‰å–å¾—ï¼‰
        const chiefOrigin = chiefRayResult.startP;
        const chiefDirection = chiefRayResult.dir;
        const chiefAtStop = chiefRay.segments[stopSurfaceIndex];
        
        console.log(`      ğŸ” Objecté¢ã§ã®ä¸»å…‰ç·šå‡ºç™ºç‚¹: (${chiefOrigin.x.toFixed(3)}, ${chiefOrigin.y.toFixed(3)}, ${chiefOrigin.z.toFixed(3)})`);
        console.log(`      ğŸ” ä¸»å…‰ç·šæ–¹å‘: (${chiefDirection.x.toFixed(6)}, ${chiefDirection.y.toFixed(6)}, ${chiefDirection.z.toFixed(6)})`);
        console.log(`      ğŸ” çµã‚Šé¢ã§ã®ä¸»å…‰ç·šä½ç½®: (${chiefAtStop.x.toFixed(3)}, ${chiefAtStop.y.toFixed(3)}, ${chiefAtStop.z.toFixed(3)})`);
        
        // çµã‚Šé¢ã®Zåº§æ¨™ã‚’è¨ˆç®—ï¼ˆç´¯ç©ï¼‰
        let stopZ = 0;
        for (let i = 0; i < stopSurfaceIndex; i++) {
            const thickness = parseFloat(opticalSystemRows[i].thickness);
            if (!isNaN(thickness) && isFinite(thickness)) {
                stopZ += thickness;
            }
        }
        
        // Draw Crossã®å¢ƒç•Œå…‰ç·šæ¤œç´¢ã‚’ä½¿ç”¨ï¼ˆstopInfoæ§‹é€ ã‚’Draw Crossã¨åˆã‚ã›ã‚‹ï¼‰
        const stopInfo = {
            surface: stopSurface,
            index: stopSurfaceIndex,
            center: { x: 0, y: 0, z: stopZ },      // çµã‚Šé¢ã®ä¸­å¿ƒåº§æ¨™ï¼ˆå…‰è»¸ä¸Šï¼‰
            position: { x: 0, y: 0, z: stopZ },    // çµã‚Šé¢ã®ä½ç½®åº§æ¨™
            radius: stopRadius,
            origin: { x: 0, y: 0, z: stopZ }       // çµã‚Šé¢ã®åŸç‚¹åº§æ¨™
        };
        
        const boundaryRays = findApertureBoundaryRays(
            chiefOrigin,       // Objecté¢ã§ã®å‡ºç™ºç‚¹
            chiefDirection,    // æ­£è¦åŒ–æ¸ˆã¿ã®æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«
            opticalSystemRows, 
            stopInfo,
            { debugMode: true, wavelength: wavelength }
        );
        
        console.log(`      ğŸ” å¢ƒç•Œå…‰ç·šæ¤œç´¢çµæœ: ${boundaryRays.length}æœ¬`);
        
        // ã‚µã‚¸ã‚¿ãƒ«æ–¹å‘ï¼ˆleft/rightï¼‰ã®å¢ƒç•Œå…‰ç·šã‚’å–å¾—
        const leftRay = boundaryRays.find(r => r.direction === 'left');
        const rightRay = boundaryRays.find(r => r.direction === 'right');
        
        if (!leftRay || !rightRay) {
            console.warn('      âš ï¸ ã‚µã‚¸ã‚¿ãƒ«: left/rightå¢ƒç•Œå…‰ç·šãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
            return null;
        }
        
        // å®‰å…¨ãƒãƒ¼ã‚¸ãƒ³ã‚’é©ç”¨ï¼ˆ70%ã®é–‹å£ã‚’ä½¿ç”¨ã—ã¦å¾Œæ®µã§ã®ã‚±ãƒ©ãƒ¬ã‚’å›é¿ï¼‰
        const safetyMargin = 0.70;
        const leftDistance = leftRay.distance * safetyMargin;
        const rightDistance = rightRay.distance * safetyMargin;
        
        console.log(`      âœ… Leftå¢ƒç•Œ: distance=${leftRay.distance.toFixed(3)}mm â†’ å®‰å…¨è·é›¢=${leftDistance.toFixed(3)}mm (${(safetyMargin*100).toFixed(0)}%)`);
        console.log(`      âœ… Rightå¢ƒç•Œ: distance=${rightRay.distance.toFixed(3)}mm â†’ å®‰å…¨è·é›¢=${rightDistance.toFixed(3)}mm (${(safetyMargin*100).toFixed(0)}%)`);
        console.log(`      ğŸ” ä¸»å…‰ç·šå‡ºç™ºç‚¹: (${chiefOrigin.x.toFixed(3)}, ${chiefOrigin.y.toFixed(3)}, ${chiefOrigin.z.toFixed(3)})`);

        
        // ä¸»å…‰ç·šã«å‚ç›´ãªåŸºåº•ãƒ™ã‚¯ãƒˆãƒ«ã‚’ç”Ÿæˆï¼ˆmakeBasisã¨åŒã˜ãƒ­ã‚¸ãƒƒã‚¯ï¼‰
        const len = Math.sqrt(chiefDirection.x * chiefDirection.x + chiefDirection.y * chiefDirection.y + chiefDirection.z * chiefDirection.z);
        const d = { x: chiefDirection.x / len, y: chiefDirection.y / len, z: chiefDirection.z / len };
        
        // ç¬¬ä¸€åŸºåº•ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆxè»¸æ–¹å‘ï¼‰- ã‚µã‚¸ã‚¿ãƒ«æ–¹å‘
        const ref = Math.abs(d.z) < 0.95 ? { x: 0, y: 0, z: 1 } : { x: 0, y: 1, z: 0 };
        let ex = {
            x: d.y * ref.z - d.z * ref.y,
            y: d.z * ref.x - d.x * ref.z,
            z: d.x * ref.y - d.y * ref.x
        };
        const exLen = Math.sqrt(ex.x * ex.x + ex.y * ex.y + ex.z * ex.z);
        ex = { x: ex.x / exLen, y: ex.y / exLen, z: ex.z / exLen };
        
        console.log(`      ğŸ” åŸºåº•ãƒ™ã‚¯ãƒˆãƒ« ex (sagittal): (${ex.x.toFixed(6)}, ${ex.y.toFixed(6)}, ${ex.z.toFixed(6)})`);
        
        // å¢ƒç•Œå…‰ç·šé–“ã§å…‰ç·šãƒ•ã‚¡ãƒ³ã‚’ç”Ÿæˆï¼ˆ7æœ¬: å¢ƒç•Œã‚’é¿ã‘ã¦ã‚ˆã‚Šå¯†ãªã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ï¼‰
        // å¢ƒç•Œä»˜è¿‘ï¼ˆÂ±1.0ï¼‰ã‚’é¿ã‘ã€Â±0.8ã¾ã§ã«åˆ¶é™ã—ã¦å®‰å…¨æ€§ã‚’ç¢ºä¿
        const fanPositions = [-0.8, -0.5, -0.2, 0, 0.2, 0.5, 0.8];
        const rayFan = [];
        
        // ç¬¬1é¢ã®åº§æ¨™ã‚’å–å¾—
        const firstSurfacePoint = chiefRay.segments[1];
        
        for (const ratio of fanPositions) {
            // å¢ƒç•Œè·é›¢ã‚’ç·šå½¢è£œé–“ã—ã¦ã‚¹ã‚±ãƒ¼ãƒ«ï¼ˆå®‰å…¨è·é›¢ã‚’ä½¿ç”¨ï¼‰
            // ratio = -1 â†’ å·¦å¢ƒç•Œã®100%, ratio = 0 â†’ 0%, ratio = +1 â†’ å³å¢ƒç•Œã®100%
            const t = (ratio + 1.0) / 2.0; // -1â†’0, 0â†’0.5, +1â†’1
            const boundaryDistance = leftDistance * (1-t) + rightDistance * t;
            
            // ratioã®çµ¶å¯¾å€¤ã§ã‚¹ã‚±ãƒ¼ãƒ«ï¼ˆ0ã€œ100%ã®è·é›¢ï¼‰
            const distance = Math.abs(ratio) * boundaryDistance;
            
            // ä¸»å…‰ç·šå‡ºç™ºç‚¹ã‹ã‚‰å‚ç›´æ–¹å‘ã«ã‚ªãƒ•ã‚»ãƒƒãƒˆã—ã¦å…‰ç·šå‡ºç™ºç‚¹ã‚’è¨ˆç®—
            // ã‚µã‚¸ã‚¿ãƒ«: exæ–¹å‘ï¼ˆx'è»¸ï¼‰ã«ã‚ªãƒ•ã‚»ãƒƒãƒˆ
            // ratio < 0 â†’ left (è² ã®æ–¹å‘), ratio > 0 â†’ right (æ­£ã®æ–¹å‘)
            const directionSign = (ratio < 0) ? -1 : (ratio > 0) ? 1 : 0;
            const effectiveDistance = distance * directionSign;
            
            const rayOrigin = {
                x: chiefOrigin.x + effectiveDistance * ex.x,
                y: chiefOrigin.y + effectiveDistance * ex.y,
                z: chiefOrigin.z + effectiveDistance * ex.z
            };
            
            console.log(`      ğŸ”¸ å…‰ç·šãƒ•ã‚¡ãƒ³ ${ratio.toFixed(1)}: distance=${distance.toFixed(3)}mm (å¢ƒç•Œ=${boundaryDistance.toFixed(3)}mm, æ–¹å‘=${directionSign}), Objecté¢å‡ºç™ºç‚¹=(${rayOrigin.x.toFixed(3)}, ${rayOrigin.y.toFixed(3)}, ${rayOrigin.z.toFixed(3)})`);
            
            // å…‰ç·šæ–¹å‘ã¯ä¸»å…‰ç·šã¨åŒã˜æ–¹å‘ã‚’ä½¿ç”¨ï¼ˆç„¡é™é ç³»ï¼‰
            const rayDirection = chiefDirection;
            
            // ç¬¬1é¢ã§ã®é–‹å§‹ç‚¹ï¼ˆå°‘ã—æ‰‹å‰ï¼‰
            const distToFirstSurface = firstSurfacePoint.z - rayOrigin.z;
            const tToFirstSurface = distToFirstSurface / rayDirection.z;
            const epsilon = -0.01;
            
            const startPoint = {
                x: rayOrigin.x + rayDirection.x * (tToFirstSurface + epsilon),
                y: rayOrigin.y + rayDirection.y * (tToFirstSurface + epsilon),
                z: firstSurfacePoint.z + epsilon
            };
            
            // å…‰ç·šè¿½è·¡ï¼ˆç¬¬1é¢ã‹ã‚‰ï¼‰
            const surfacesFromFirst = opticalSystemRows.slice(1);
            const ray0 = { pos: startPoint, dir: rayDirection };
            
            // ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ç”¨é…åˆ—
            const debugLog = [];
            const segments = traceRay(surfacesFromFirst, ray0, 1.0, debugLog);
            
            if (!segments || !Array.isArray(segments)) {
                console.warn(`      âš ï¸ ã‚µã‚¸ã‚¿ãƒ«å…‰ç·šè¿½è·¡å¤±æ•—: segments=${segments}`);
                if (debugLog.length > 0) {
                    console.log(`      ğŸ“ ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚° (æœ€å¾Œã®10è¡Œ):`, debugLog.slice(-10));
                }
                continue;
            }
            
            console.log(`      âœ… ã‚µã‚¸ã‚¿ãƒ«å…‰ç·šè¿½è·¡æˆåŠŸ: ${segments.length}ã‚»ã‚°ãƒ¡ãƒ³ãƒˆ`);
            
            // traceRayã¯ç¬¬1é¢ã‹ã‚‰å§‹ã¾ã‚‹ã®ã§ã€ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’èª¿æ•´
            // targetSurfaceIndexã¯çµ¶å¯¾ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆç¬¬0é¢èµ·ç‚¹ï¼‰
            // segmentsã¯ç¬¬1é¢èµ·ç‚¹ãªã®ã§ã€targetSurfaceIndex - 1 ã‚’ä½¿ç”¨
            const adjustedIndex = targetSurfaceIndex - 1;
            
            console.log(`      ğŸ” å¿…è¦ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæ•°: ${adjustedIndex + 2} (èª¿æ•´æ¸ˆã¿ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹=${adjustedIndex}+2)`);
            
            if (segments.length > adjustedIndex + 1) {
                // ç¬¬0é¢ã®æƒ…å ±ã‚’è¿½åŠ ã—ã¦ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’åˆã‚ã›ã‚‹
                const adjustedSegments = [rayOrigin, ...segments];
                rayFan.push({ segments: adjustedSegments });
                console.log(`      âœ… ã‚µã‚¸ã‚¿ãƒ«å…‰ç·šãƒ•ã‚¡ãƒ³è¿½åŠ æˆåŠŸ: èª¿æ•´å¾Œã‚»ã‚°ãƒ¡ãƒ³ãƒˆæ•°=${adjustedSegments.length}`);
            } else {
                console.warn(`      âš ï¸ ã‚µã‚¸ã‚¿ãƒ«ã‚»ã‚°ãƒ¡ãƒ³ãƒˆä¸è¶³: ${segments.length} <= ${adjustedIndex + 1}ï¼ˆã‚±ãƒ©ãƒ¬ã¾ãŸã¯åˆ°é”ä¸å¯ï¼‰`);
            }
        }
        
        console.log(`      ğŸ“Š ã‚µã‚¸ã‚¿ãƒ«å…‰ç·šãƒ•ã‚¡ãƒ³: ${rayFan.length}/${fanPositions.length} æœ¬è¿½è·¡æˆåŠŸ`);
        
        if (rayFan.length === 0) {
            console.warn('      âš ï¸ ã‚µã‚¸ã‚¿ãƒ«: å…‰ç·šãƒ•ã‚¡ãƒ³ãŒ1æœ¬ã‚‚è¿½è·¡ã§ãã¾ã›ã‚“ã§ã—ãŸ');
            return null;
        }
        
        // RMSãƒ™ãƒ¼ã‚¹ã®æœ€è‰¯ç„¦ç‚¹æ¢ç´¢
        const bestZ = findBestFocusZ(rayFan, chiefRay, targetSurfaceIndex, paraxialZ, 'sagittal');
        
        if (bestZ === null) {
            console.warn('      âš ï¸ ã‚µã‚¸ã‚¿ãƒ«: æœ€è‰¯ç„¦ç‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ');
            return null;
        }
        
        return bestZ;
        
    } catch (error) {
        console.error('      âŒ ã‚µã‚¸ã‚¿ãƒ«å…‰ç·šè¿½è·¡ã‚¨ãƒ©ãƒ¼:', error);
        return null;
    }
}

/**
 * ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¨­å®šã‚’å–å¾—
 * @returns {Array} ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¨­å®šã®é…åˆ—
 */
function getFieldSettingsFromObject() {
    try {
        const objectRows = getObjectRows();
        if (!objectRows || objectRows.length === 0) {
            console.warn('âš ï¸ Object ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
            return [];
        }
        
        console.log(`   Objectè¡Œæ•°: ${objectRows.length}`);
        console.log(`   ğŸ” Objectç”Ÿãƒ‡ãƒ¼ã‚¿:`, objectRows);
        
        const fieldSettings = [];
        
        for (let i = 0; i < objectRows.length; i++) {
            const obj = objectRows[i];
            const name = obj.name || obj.Name || `Object${i + 1}`;
            
            // ä½ç½®ã‚¿ã‚¤ãƒ—ã‚’åˆ¤å®š
            const positionType = (obj.position || obj.fieldType || obj.type || '').toLowerCase();
            const isAngle = positionType.includes('angle');
            
            console.log(`   Object ${i + 1}: name="${name}", position="${positionType}", isAngle=${isAngle}`);
            console.log(`      ç”Ÿãƒ‡ãƒ¼ã‚¿:`, obj);
            
            // Xåº§æ¨™ã‚’å–å¾—
            let xValue = 0;
            if (isAngle) {
                xValue = parseFloat(obj.xFieldAngle || obj.xAngle || obj.xHeightAngle || obj.x || 0);
            } else {
                xValue = parseFloat(obj.xHeight || obj.x || obj.xFieldAngle || obj.xAngle || 0);
            }
            
            // Yåº§æ¨™ã‚’å–å¾—
            let yValue = 0;
            if (isAngle) {
                yValue = parseFloat(obj.yFieldAngle || obj.fieldAngle || obj.yAngle || obj.yHeightAngle || obj.y || 0);
            } else {
                yValue = parseFloat(obj.yHeight || obj.y || obj.yFieldAngle || obj.yAngle || 0);
            }
            
            console.log(`      è§£æçµæœ: x=${xValue}, y=${yValue}`);
            
            fieldSettings.push({
                name: name,
                displayName: name,
                x: xValue,
                y: yValue,
                fieldType: isAngle ? 'angle' : 'height',
                objectIndex: i,
                position: positionType
            });
        }
        
        console.log(`   âœ… ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¨­å®šå–å¾—å®Œäº†: ${fieldSettings.length}ä»¶`);
        return fieldSettings;
        
    } catch (error) {
        console.error('âŒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¨­å®šå–å¾—ã‚¨ãƒ©ãƒ¼:', error);
        return [];
    }
}

/**
 * ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¨­å®šã‚’è£œé–“ã—ã¦ç‚¹æ•°ã‚’å¢—ã‚„ã™
 * @param {Array} originalFields - å…ƒã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¨­å®š
 * @param {number} totalPoints - ç›®æ¨™ç‚¹æ•°ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 9ï¼‰
 * @returns {Array} è£œé–“ã•ã‚ŒãŸãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¨­å®š
 */
function interpolateFieldSettings(originalFields, totalPoints = 9) {
    if (!originalFields || originalFields.length === 0) {
        return [];
    }
    
    // Yè§’åº¦ã§ã‚½ãƒ¼ãƒˆ
    const sortedFields = [...originalFields].sort((a, b) => a.y - b.y);
    
    const minAngle = sortedFields[0].y;
    const maxAngle = sortedFields[sortedFields.length - 1].y;
    
    console.log(`   ğŸ“Š è£œé–“: ${originalFields.length}ç‚¹ â†’ ${totalPoints}ç‚¹ (${minAngle}Â° ~ ${maxAngle}Â°)`);
    
    const interpolatedFields = [];
    
    for (let i = 0; i < totalPoints; i++) {
        const targetAngle = minAngle + (maxAngle - minAngle) * i / (totalPoints - 1);
        
        interpolatedFields.push({
            name: `Field${i + 1}`,
            displayName: `${targetAngle.toFixed(1)}Â°`,
            x: 0,
            y: targetAngle,
            fieldType: 'angle',
            objectIndex: -1, // è£œé–“ã•ã‚ŒãŸç‚¹
            position: 'angle',
            isInterpolated: true
        });
    }
    
    return interpolatedFields;
}

/**
 * éç‚¹åå·®ãƒ‡ãƒ¼ã‚¿ã‚’è¨ˆç®—
 * @param {Array} opticalSystemRows - å…‰å­¦ç³»ãƒ‡ãƒ¼ã‚¿
 * @param {number} targetSurfaceIndex - è©•ä¾¡é¢ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
 * @param {Array} wavelengths - æ³¢é•·ã®é…åˆ— (Î¼m)
 * @param {Array} fieldSettings - ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¨­å®šï¼ˆnull ã®å ´åˆã¯è‡ªå‹•å–å¾—ï¼‰
 * @param {number} interpolationPoints - è£œé–“ã™ã‚‹ç‚¹æ•°ï¼ˆ0ã®å ´åˆã¯è£œé–“ãªã—ï¼‰
 * @returns {Object} éç‚¹åå·®ãƒ‡ãƒ¼ã‚¿
 */
export function calculateAstigmatismData(opticalSystemRows, targetSurfaceIndex, wavelengths = [0.5876], fieldSettings = null, interpolationPoints = 9) {
    console.log('ğŸ¯ éç‚¹åå·®è¨ˆç®—é–‹å§‹');
    console.log(`   è©•ä¾¡é¢: Surface ${targetSurfaceIndex + 1}`);
    console.log(`   æ³¢é•·æ•°: ${wavelengths.length}`);
    
    try {
        // ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¨­å®šã‚’å–å¾—
        if (!fieldSettings) {
            console.log('   ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¨­å®šã‚’è‡ªå‹•å–å¾—ä¸­...');
            fieldSettings = getFieldSettingsFromObject();
        }
        
        if (!fieldSettings || fieldSettings.length === 0) {
            console.error('âŒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¨­å®šãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ');
            return {
                targetSurface: targetSurfaceIndex,
                wavelengths: wavelengths,
                fieldSettings: [],
                data: []
            };
        }
        
        console.log(`   å…ƒã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰æ•°: ${fieldSettings.length}`);
        console.log(`   å…ƒã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¨­å®š:`, fieldSettings.map(f => `${f.displayName} (y=${f.y}Â°)`));
        
        // è£œé–“ã—ã¦ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰æ•°ã‚’å¢—ã‚„ã™
        if (interpolationPoints > 0 && interpolationPoints > fieldSettings.length) {
            fieldSettings = interpolateFieldSettings(fieldSettings, interpolationPoints);
        }
        
        console.log(`   è¨ˆç®—ã™ã‚‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰æ•°: ${fieldSettings.length}`);
        console.log(`   æœ€çµ‚ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¨­å®š:`, fieldSettings.map(f => `${f.displayName} (y=${f.y}Â°)`));
        
        // çµã‚Šé¢ã‚’æ¤œå‡º
        const stopSurfaceIndex = findStopSurfaceIndex(opticalSystemRows);
        console.log(`   çµã‚Šé¢: Surface ${stopSurfaceIndex + 1}`);
        
        // Calculate relative index from stop surface
        // Ray tracing starts at stop surface, so segment index 0 = stop surface
        // targetSurfaceIndex is absolute, so we need to subtract stopSurfaceIndex
        const relativeTargetIndex = targetSurfaceIndex - stopSurfaceIndex;
        console.log(`   è©•ä¾¡é¢ã®ç›¸å¯¾ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹: ${relativeTargetIndex} (çµã‚Šé¢ã‹ã‚‰${relativeTargetIndex}é¢å¾Œ)`);
        
        const astigmatismData = {
            targetSurface: targetSurfaceIndex,
            stopSurface: stopSurfaceIndex,
            relativeTargetIndex: relativeTargetIndex,
            wavelengths: wavelengths,
            fieldSettings: fieldSettings,
            data: [] // { wavelength, fieldAngle, paraxialImageZ, meridionalDeviation, sagittalDeviation }
        };
        
        // å„æ³¢é•·ã«ã¤ã„ã¦è¨ˆç®—
        for (const wavelength of wavelengths) {
            console.log(`\nğŸ“Š æ³¢é•· ${wavelength}Î¼m ã®è¨ˆç®—ä¸­...`);
            
            // å„ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¨­å®šã«ã¤ã„ã¦è¨ˆç®—
            for (let i = 0; i < fieldSettings.length; i++) {
                const fieldSetting = fieldSettings[i];
                
                // ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è§’ã‚’å–å¾—ï¼ˆè§’åº¦ã®å ´åˆã¯ãã®ã¾ã¾ã€é«˜ã•ã®å ´åˆã¯0ã¨ã™ã‚‹ï¼‰
                let fieldAngle;
                const fieldType = (fieldSetting.fieldType || '').toLowerCase();
                
                if (fieldType === 'angle') {
                    // Yæ–¹å‘ã®è§’åº¦ã‚’ä½¿ç”¨ï¼ˆè¤‡æ•°ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åã«å¯¾å¿œï¼‰
                    fieldAngle = Math.abs(
                        fieldSetting.yFieldAngle || 
                        fieldSetting.fieldAngle || 
                        fieldSetting.y || 
                        fieldSetting.yHeightAngle || 
                        0
                    );
                } else {
                    // é«˜ã•ã®å ´åˆã¯yHeightå€¤ã‚’ä½¿ç”¨ã€ã¾ãŸã¯0
                    fieldAngle = Math.abs(fieldSetting.yHeight || fieldSetting.y || 0);
                }
                
                console.log(`   ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ ${i + 1}/${fieldSettings.length}: ${fieldSetting.displayName} (${fieldAngle}Â°)`);
                
                try {
                    // ä¸»å…‰ç·šã‚’è¨ˆç®—ï¼ˆè¿‘è»¸åƒç‚¹è¨ˆç®—ã«å¿…è¦ï¼‰
                    const chiefRayResult = calculateChiefRayNewton(opticalSystemRows, fieldSetting, wavelength, 'unified');
                    if (!chiefRayResult || !chiefRayResult.success) {
                        console.warn(`      âš ï¸ ä¸»å…‰ç·šã®è¨ˆç®—ã«å¤±æ•—ã—ã¾ã—ãŸ`);
                        continue;
                    }
                    
                    const chiefRay = chiefRayResult.rayData;
                    if (!chiefRay || !chiefRay.segments) {
                        console.warn(`      âš ï¸ ä¸»å…‰ç·šãƒ‡ãƒ¼ã‚¿ãŒä¸æ­£ã§ã™`);
                        continue;
                    }
                    
                    console.log(`      ğŸ” ä¸»å…‰ç·šã‚»ã‚°ãƒ¡ãƒ³ãƒˆæ•°: ${chiefRay.segments.length}`);
                    console.log(`      ğŸ” è©•ä¾¡é¢çµ¶å¯¾ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹: ${targetSurfaceIndex}`);
                    console.log(`      ğŸ” çµã‚Šé¢ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹: ${stopSurfaceIndex}`);
                    
                    // è¿‘è»¸åƒç‚¹ï¼ˆç†æƒ³åƒç‚¹ï¼‰ã‚’è¨ˆç®—ï¼ˆçµ¶å¯¾ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ä½¿ç”¨ï¼‰
                    const paraxialImageZ = calculateParaxialImagePosition(chiefRay, targetSurfaceIndex);
                    if (paraxialImageZ === null) {
                        console.warn(`      âš ï¸ è¿‘è»¸åƒç‚¹è¨ˆç®—å¤±æ•—`);
                        continue;
                    }
                    
                    // ãƒ¡ãƒªãƒ‡ã‚£ã‚ªãƒŠãƒ«ï¼ˆMeridional, Mï¼‰æœ€è‰¯ç„¦ç‚¹ã‚’è¨ˆç®—ï¼ˆRMSãƒ™ãƒ¼ã‚¹ï¼‰
                    console.log(`      ğŸ”µ ãƒ¡ãƒªãƒ‡ã‚£ã‚ªãƒŠãƒ«å…‰ç·šãƒ•ã‚¡ãƒ³è¿½è·¡é–‹å§‹...`);
                    const meridionalFocusZ = traceMeridionalMarginalRay(
                        opticalSystemRows,
                        chiefRay,
                        chiefRayResult,  // calculateChiefRayNewtonã®å®Œå…¨ãªè¿”ã‚Šå€¤ã‚’æ¸¡ã™
                        wavelength,
                        stopSurfaceIndex,
                        targetSurfaceIndex, // çµ¶å¯¾ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ä½¿ç”¨
                        paraxialImageZ
                    );
                    
                    // ã‚µã‚¸ã‚¿ãƒ«ï¼ˆSagittal, Sï¼‰æœ€è‰¯ç„¦ç‚¹ã‚’è¨ˆç®—ï¼ˆRMSãƒ™ãƒ¼ã‚¹ï¼‰
                    console.log(`      ğŸ”¶ ã‚µã‚¸ã‚¿ãƒ«å…‰ç·šãƒ•ã‚¡ãƒ³è¿½è·¡é–‹å§‹...`);
                    const sagittalFocusZ = traceSagittalMarginalRay(
                        opticalSystemRows,
                        chiefRay,
                        chiefRayResult,  // calculateChiefRayNewtonã®å®Œå…¨ãªè¿”ã‚Šå€¤ã‚’æ¸¡ã™
                        wavelength,
                        stopSurfaceIndex,
                        targetSurfaceIndex, // çµ¶å¯¾ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ä½¿ç”¨
                        paraxialImageZ
                    );
                    
                    console.log(`      ğŸ” æœ€è‰¯ç„¦ç‚¹: meridionalZ=${meridionalFocusZ}, sagittalZ=${sagittalFocusZ}`);
                    
                    // è¿‘è»¸åƒç‚¹ã‹ã‚‰ã®å·®åˆ†ã‚’è¨ˆç®—
                    const meridionalDeviation = meridionalFocusZ !== null ? meridionalFocusZ - paraxialImageZ : null;
                    const sagittalDeviation = sagittalFocusZ !== null ? sagittalFocusZ - paraxialImageZ : null;
                    
                    console.log(`      ğŸ“ ç„¦ç‚¹ä½ç½®: meridional=${meridionalFocusZ}, sagittal=${sagittalFocusZ}`);
                    console.log(`      ğŸ“ è¿‘è»¸åƒç‚¹ã‹ã‚‰ã®å·®åˆ†: M=${meridionalDeviation}, S=${sagittalDeviation}`);
                    
                    if (meridionalDeviation !== null && sagittalDeviation !== null) {
                        console.log(`      âœ… ãƒ¡ãƒªãƒ‡ã‚£ã‚ªãƒŠãƒ«å·®åˆ†: ${meridionalDeviation.toFixed(4)}mm`);
                        console.log(`      âœ… ã‚µã‚¸ã‚¿ãƒ«å·®åˆ†: ${sagittalDeviation.toFixed(4)}mm`);
                        console.log(`      âœ… éç‚¹éš”å·®: ${Math.abs(meridionalDeviation - sagittalDeviation).toFixed(4)}mm`);
                        
                        astigmatismData.data.push({
                            wavelength: wavelength,
                            fieldAngle: fieldAngle,
                            fieldName: fieldSetting.displayName,
                            paraxialImageZ: paraxialImageZ,
                            meridionalDeviation: meridionalDeviation,
                            sagittalDeviation: sagittalDeviation,
                            astigmaticDifference: Math.abs(meridionalDeviation - sagittalDeviation)
                        });
                    } else {
                        console.warn(`      âš ï¸ ç„¦ç‚¹è¨ˆç®—å¤±æ•— (meridional: ${meridionalDeviation}, sagittal: ${sagittalDeviation})`);
                    }
                } catch (fieldError) {
                    console.error(`      âŒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ ${i + 1} (${fieldAngle}Â°) ã®è¨ˆç®—ã‚¨ãƒ©ãƒ¼:`, fieldError);
                    console.error(`      ã‚¨ãƒ©ãƒ¼ã‚¹ã‚¿ãƒƒã‚¯:`, fieldError.stack);
                }
            }
        }
        
        console.log(`\nâœ… éç‚¹åå·®è¨ˆç®—å®Œäº†: ${astigmatismData.data.length}ç‚¹`);
        
        return astigmatismData;
        
    } catch (error) {
        console.error('âŒ éç‚¹åå·®è¨ˆç®—ã§äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼:', error);
        return {
            targetSurface: targetSurfaceIndex,
            wavelengths: wavelengths,
            fieldSettings: fieldSettings || [],
            data: []
        };
    }
}
