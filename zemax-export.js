// Zemax OpticStudio ZMX export (minimal subset)
// - Outputs UTF-16LE (with BOM) for compatibility
// - Supports: STANDARD, EVENASPH (via TYPE EVENASPH + CONI + PARM)
// - Detects unsupported: Aspheric odd, Coord Break (aborts)

function isBlank(v) {
  return v === null || v === undefined || String(v).trim() === '';
}

function parseNumberOrNull(v) {
  if (v === null || v === undefined) return null;
  if (typeof v === 'number' && Number.isFinite(v)) return v;
  const s = String(v).trim();
  if (s === '') return null;
  if (/^inf(inity)?$/i.test(s)) return Infinity;
  const n = Number(s);
  return Number.isFinite(n) ? n : null;
}

function normalizeMaterialName(material) {
  const s = String(material ?? '').trim();
  if (s === '') return 'AIR';
  // Common variants
  if (s.toUpperCase() === 'AIR') return 'AIR';
  if (s.toUpperCase() === 'VACUUM') return 'AIR';
  return s;
}

function encodeUtf16LeWithBom(str) {
  // UTF-16LE BOM
  const out = new Uint8Array(2 + str.length * 2);
  out[0] = 0xff;
  out[1] = 0xfe;
  for (let i = 0; i < str.length; i++) {
    const codeUnit = str.charCodeAt(i);
    out[2 + i * 2] = codeUnit & 0xff;
    out[2 + i * 2 + 1] = (codeUnit >> 8) & 0xff;
  }
  return out;
}

function inferUnsupportedSurfaceTypes(rows) {
  const odd = [];
  const coord = [];

  for (let i = 0; i < rows.length; i++) {
    const r = rows[i] ?? {};
    const surfType = String(r.surfType ?? '').trim();
    if (surfType === 'Aspheric odd') odd.push(i + 1);
    if (surfType === 'Coord Break' || surfType === 'Coordinate Break' || surfType === 'CB') coord.push(i + 1);
  }

  return { odd, coord };
}

function formatFloat(v) {
  // Keep Zemax-friendly plain decimals, avoid scientific for typical sizes.
  if (!Number.isFinite(v)) return '0';
  // For very small/large values, scientific is fine.
  const av = Math.abs(v);
  if (av !== 0 && (av < 1e-6 || av > 1e6)) return String(v);
  return Number(v.toFixed(15)).toString();
}

function normalizeArray(value) {
  return Array.isArray(value) ? value : [];
}

function inferPrimaryWavelengthIndexOneBased(sourceRows) {
  for (let i = 0; i < sourceRows.length; i++) {
    const r = sourceRows[i] ?? {};
    const primary = String(r.primary ?? '').trim();
    if (primary) return i + 1;
  }
  return 1;
}

export function generateZMXText(opticalSystemRows, options = {}) {
  const rows = Array.isArray(opticalSystemRows) ? opticalSystemRows : [];

  const { odd, coord } = inferUnsupportedSurfaceTypes(rows);
  if (odd.length > 0) {
    const list = odd.slice(0, 20).join(', ');
    const more = odd.length > 20 ? ` (+${odd.length - 20} more)` : '';
    const err = new Error(`Zemax export: Aspheric odd surfaces are not supported yet. Surface(s): ${list}${more}`);
    err.code = 'ZMX_UNSUPPORTED_ODD';
    throw err;
  }
  if (coord.length > 0) {
    const list = coord.slice(0, 20).join(', ');
    const more = coord.length > 20 ? ` (+${coord.length - 20} more)` : '';
    const err = new Error(`Zemax export: Coord Break surfaces are not supported yet. Surface(s): ${list}${more}`);
    err.code = 'ZMX_UNSUPPORTED_COORDBRK';
    throw err;
  }

  const title = String(options.title ?? 'co-opt export').replace(/\r?\n/g, ' ').trim();
  const units = String(options.units ?? 'MM').trim().toUpperCase();

  const lines = [];
  lines.push(`UNIT ${units}`);
  if (title) lines.push(`NAME "${title.replace(/\"/g, "'")}"`);
  lines.push('NOTE "Generated by co-opt"');

  // --- System-level data (minimal) ---
  // Wavelengths (from source table)
  const sourceRows = normalizeArray(options.sourceRows);
  if (sourceRows.length > 0) {
    for (let i = 0; i < sourceRows.length; i++) {
      const r = sourceRows[i] ?? {};
      const wl = parseNumberOrNull(r.wavelength);
      if (wl !== null && Number.isFinite(wl) && wl > 0) {
        lines.push(`WAVL ${formatFloat(wl)}`);
      }
    }
    for (let i = 0; i < sourceRows.length; i++) {
      const r = sourceRows[i] ?? {};
      const w = parseNumberOrNull(r.weight);
      if (w !== null && Number.isFinite(w)) {
        lines.push(`WWGT ${formatFloat(w)}`);
      }
    }

    const primaryIndex = inferPrimaryWavelengthIndexOneBased(sourceRows);
    if (primaryIndex > 0) {
      lines.push(`PWAV ${primaryIndex}`);
    }
  }

  // Fields (from object table)
  const objectRows = normalizeArray(options.objectRows);
  if (objectRows.length > 0) {
    // Co-Opt's object table commonly stores field angles in degrees.
    lines.push('FTYP 1');
    for (let i = 0; i < objectRows.length; i++) {
      const r = objectRows[i] ?? {};
      const x = parseNumberOrNull(r.xHeightAngle);
      const y = parseNumberOrNull(r.yHeightAngle);
      if ((x !== null && Number.isFinite(x)) || (y !== null && Number.isFinite(y))) {
        lines.push(`XFLD ${formatFloat(Number.isFinite(x) ? x : 0)}`);
        lines.push(`YFLD ${formatFloat(Number.isFinite(y) ? y : 0)}`);
        lines.push('FWGT 1');
      }
    }
  }

  // Entrance pupil diameter (best-effort; caller can provide via paraxial calc)
  const enpd = parseNumberOrNull(options.entrancePupilDiameterMm ?? options.pupilDiameterMm);
  if (enpd !== null && Number.isFinite(enpd) && enpd > 0) {
    lines.push(`ENPD ${formatFloat(enpd)}`);
  }

  for (let i = 0; i < rows.length; i++) {
    const row = rows[i] ?? {};
    lines.push(`SURF ${i}`);

    const objectType = String(row['object type'] ?? '').trim();
    if (objectType === 'Stop') {
      lines.push('STOP');
    }

    // Radius -> curvature
    const radius = parseNumberOrNull(row.radius);
    let curvature = 0;
    if (radius === null) {
      curvature = 0;
    } else if (radius === Infinity) {
      curvature = 0;
    } else if (radius === 0) {
      curvature = 0;
    } else {
      curvature = 1 / radius;
    }
    lines.push(`CURV ${formatFloat(curvature)}`);

    // Thickness
    const thickness = parseNumberOrNull(row.thickness);
    let disz = 0;
    if (thickness === null) {
      disz = 0;
    } else if (thickness === Infinity) {
      // Avoid INF tokens; use large finite placeholder.
      disz = 1e10;
    } else {
      disz = thickness;
    }
    lines.push(`DISZ ${formatFloat(disz)}`);

    // Glass (gap medium after surface)
    const mat = normalizeMaterialName(row.material);
    if (!isBlank(mat)) {
      lines.push(`GLAS ${mat}`);
    }

    // Aperture (semi-diameter)
    const semidia = parseNumberOrNull(row.semidia);
    if (semidia !== null && Number.isFinite(semidia) && semidia > 0) {
      // Use circular clear aperture type=1 per common usage.
      lines.push(`DIAM ${formatFloat(semidia)} 1 0 0 1 ""`);
    }

    const surfType = String(row.surfType ?? '').trim();
    if (surfType === 'Aspheric even') {
      lines.push('TYPE EVENASPH');

      const conic = parseNumberOrNull(row.conic);
      if (conic !== null && Number.isFinite(conic) && conic !== 0) {
        lines.push(`CONI ${formatFloat(conic)}`);
      }

      // Map coef1..coef10 => PARM 1..10
      for (let j = 1; j <= 10; j++) {
        const key = `coef${j}`;
        const val = parseNumberOrNull(row[key]);
        if (val === null || !Number.isFinite(val) || val === 0) continue;
        lines.push(`PARM ${j} ${formatFloat(val)}`);
      }
    } else {
      // Standard / spherical
      const conic = parseNumberOrNull(row.conic);
      if (conic !== null && Number.isFinite(conic) && conic !== 0) {
        // Zemax uses Conic on Standard surfaces too.
        lines.push(`CONI ${formatFloat(conic)}`);
      }
    }

    // Comments
    const comment = String(row.comment ?? '').trim();
    if (comment) {
      lines.push(`COMM "${comment.replace(/\"/g, "'")}"`);
    }
  }

  lines.push('');
  return lines.join('\n');
}

export function downloadZMX(zmxText, filename) {
  const name = String(filename ?? 'co-opt-export.zmx').trim() || 'co-opt-export.zmx';
  const ensured = name.toLowerCase().endsWith('.zmx') ? name : `${name}.zmx`;

  const bytes = encodeUtf16LeWithBom(String(zmxText ?? ''));
  const blob = new Blob([bytes], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = ensured;
  a.click();
  URL.revokeObjectURL(url);
}
